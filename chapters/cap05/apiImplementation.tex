\section[Implementação da API]{Implementação da API}\label{sec:api}
Como explicado na seção sobre a arquitetura ~\ref{subsec:apiArchitecture}, a \gls{API} possui um divisão por módulos, e cada modulo segue uma estrutura pré definida, com uma camada de controller, responsável por receber as requisições \gls{HTTP}, uma camada de service, responsável por tratar os dados e regras de negócio, e uma camada de respository, responsável por gerenciar o acesso ao banco de dados daquele modulo. 

Além disso, a \gls{API} possui também partes que são comuns a todos os módulos. A infraestrutura que tem a função de disponibilizar uma interface de acesso ao banco de dados, uma interface de acesso para envio de mensagens web socket, os meios de autenticação, e o gerenciador de threads. Os códigos comuns, que armazenam constantes, funções comuns que precisam ser padronizadas, e modelos de dados.

Portanto, essa seção irá abordar cada uma dessas partes, passando primeiro pelas partes comuns do sistema e depois será mostrado como foi desenvolvido um modulo completo.

\subsection{Inicialização}\label{subsec:main}
A inicialização do sistema acontece por meio do arquivo \texttt{main.py}, que serve como o ponto de entrada para inicializar a \gls{API} e o modulo de processamento de dados.
%TODO ref para o fastapi
A biblioteca \texttt{FastAPI} é utilizada para criar a aplicação principal, aqui referida como \texttt{app}. O middleware \texttt{CORSMiddleware} é adicionado à aplicação \texttt{FastAPI}, permitindo uma configuração de \gls{CORS} (Cross-Origin Resource Sharing) abrangente. Esta configuração faz com que a \gls{API} possa ser acessada por diferentes origens.

A importação do módulo \texttt{API\_data\_layer} não apenas incorpora as rotas relacionadas a esse módulo, mas também inicializa o módulo de recebimento de dados. Isso implica que a inicialização deste módulo ocorre simultaneamente ao carregamento da \gls{API}, porem em uma thread separada, como detalhado em ~\ref{subsec:}.%TODO ref para a implementação do modulo de processamento de dados

Para o gerenciamento de metadados, uma instância do \texttt{MetadataRepository} é criada durante a inicialização. Este componente é essencial para o carregamento dos metadados que são utilizados em diferentes partes do sistema, como constantes e parâmetros de alarme.

As rotas da \gls{API} são então incluídas na aplicação principal através do método \texttt{include\_router} para diferentes módulos, como autenticação, análise de API, camada de dados, notificações e usuários.

Adicionalmente, o WebSocket é montado na raiz da aplicação através do objeto \texttt{socketio\_app}, possibilitando a comunicação em tempo real entre o servidor e os clientes. A implementação da conexão websocket pode ser vista em ~\ref{subsec:}.%TODO ref para a implementação da classe de conexão websocket


A execução do arquivo se conclui com a inicialização do servidor \texttt{Uvicorn}, definindo o host e a porta para escuta. \texttt{Uvicorn} é um servidor \gls{ASGI} que serve como a interface entre o código da aplicação e o servidor web. Ele é responsável por hospedar a aplicação \texttt{FastAPI} e escutar por conexões de entrada no host e na porta especificados. A escolha deste servidor foi pautada na recomendação da documentação do FastAPI.%TODO ref para a doc do fast api

\begin{verbatim}
from fastapi import FastAPI
import uvicorn
from fastapi.middleware.cors import CORSMiddleware
from src.infrastructure.database.metadata.metadata_repository import (
MetadataRepository)
from src.modules.api_analytics import api_analytics_router
from src.modules.api_data_layer import api_data_layer_router
from src.modules.notifications import notification_module_router
from src.modules.user import user_module_router, auth_router
from src.infrastructure.websocket import socketio_app
from src.infrastructure.websocket import socket_dispacher
from dotenv import load_dotenv

load_dotenv()
MetadataRepository()
socket_dispacher
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)
@app.get("/")
async def health_check():
    return {
        "Status":"OK",
        "Message":"Access /docs to more information"    
    }
app.include_router(auth_router)
app.include_router(api_analytics_router)
app.include_router(api_data_layer_router)
app.include_router(notification_module_router)
app.include_router(user_module_router)

app.mount("/",socketio_app)

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
\end{verbatim}

\subsection{Infraestrutura}\label{subsec:infra}

A infraestrutura e composta de 4 sub-módulos, Autenticação, WebSocket, Conexão com o banco de dados e Gerenciamento de Threads.

\subsubsection{Authetication}\label{subsubsec:auth}
%TODO referencia para JWT
%TODO referencia para auth do fastAPI
A implementação da autenticação do sistema foi baseada na documentação oficial do FastAPI, portanto foi adotada uma abordagem baseada em tokens \gls{JWT}. O \gls{JWT} é um padrão amplamente aceito para transmitir informações entre partes de maneira segura. A estrutura de um \gls{JWT} é codificada e pode ser verificada para assegurar que os dados não foram alterados durante a transmissão. 

O ponto de entrada para a autenticação é o \texttt{o\_auth2\_password\_bearer}, uma instância do OAuth2PasswordBearer que é designada para obter o token a partir do cabeçalho da requisição. O método \texttt{auth\_middleware} foi definido como um middleware assíncrono, que depende deste bearer token. Esse middleware é utilizado nos controllers para verificar se a requisição recebida tem ou não permissão para acessar as informações.


Dentro deste middleware, a função \texttt{decode\_jwt\_token} é invocada para decodificar e validar o token \gls{JWT} fornecido.

\begin{verbatim}
o_auth2_password_bearer = OAuth2PasswordBearer(tokenUrl="/user/login")

async def auth_middleware(token:str = Depends(o_auth2_password_bearer))-> TokenPayload:
    try:
        result = decode_jwt_token(token)
        if result.status:
            return result.data
        else:
            raise HTTPException(status_code=401, detail=result.exception.message)
    except JWSError as jwt_err:
        print(jwt_err)
        raise HTTPException(status_code=401, detail=Unauthorized().message)
\end{verbatim}

A função \texttt{decode\_jwt\_token} recebe um token como argumento e tenta decodificá-lo usando a chave secreta e o algoritmo especificados. Se o token for decodificado com sucesso e for do tipo "\texttt{access\_token}". Caso contrário, diferentes tipos de exceções podem ser levantadas, por exemplo, se o token estiver expirado ou se houver algum erro nas operações de \gls{JWT}.

\begin{verbatim}
def decode_jwt_token(token:str)->Result[TokenPayload|None]:
    try:
        token_dict = jwt.decode(token,key=SECRET_KEY, algorithms=ALGORITHM)
        if token_dict["type"] != "access_token":
            return Result(status=False, exception=WrongTokenType(), data=None)
        token_payload = TokenPayload(**token_dict)
        return Result(status=True, data=token_payload, exception=None)
    
    except ExpiredSignatureError as invalid_token:
        return Result(status=False, exception=Unauthorized(exception=invalid_token), data=None)

    except (JWSError, JOSEError, JWTError, JWEError) as ex:
        return Result(status=False, exception=GenericException(message="Authorization error!",exception=ex), data=None)

    except Exception as ex:
        print(ex)
        raise ex
\end{verbatim}

A classe modelo para o payload do token é a seguinte:
\begin{verbatim}
class TokenPayload(BaseModel):
    name:str
    exp:int|None = None
    sub:str|None = None
    user_id:str
    type:str = "access_token"
\end{verbatim}

A classe \texttt{AuthService} é onde a lógica principal de autenticação é implementada. Esta classe segue o padrão \textit{Singleton} para garantir que apenas uma instância seja criada e usada ao longo da execução do programa.

Dentro de \texttt{AuthService}, o método \texttt{verify\_password} é utilizado para verificar se uma senha fornecida coincide com uma senha criptografada, enquanto o \texttt{hash\_password} é responsável por criptografar uma senha fornecida.

O método \texttt{create\_user\_tokens} gera um par de tokens (access e refresh) para um usuário, onde o access token é válido por 4 horas e o refresh token por 168 horas. O refresh token é especialmente importante para permitir que os usuários obtenham novos tokens de acesso sem ter que inserir suas credenciais novamente. Se o token de acesso expirar, o token de atualização pode ser usado para obter um novo par de tokens, usando o método \texttt{get\_new\_user\_tokens}. Importante destacar que o frontend ainda não faz uso do refresh token, ficando essa funcionalidade para uma futura implementação.

\begin{verbatim}
class AuthService(metaclass=Singleton):
    def __init__(self):
        self.__database__ = MongoDB()
        self.__user_repository = UserRepository()

        self.__ACCESS_TOKEN_EXPIRE_HOURS__ = 4
        self.__REFRESH_TOKEN_EXPIRE_HOURS__ = 168
        self.__SECRET_KEY__ = SECRET_KEY
        self.__ALGORITHM__ = ALGORITHM
        self.__pwd_context__ = CryptContext(
            schemes=["bcrypt"],
            deprecated="auto")

    def verify_password(self,plain_text_password:str, hashed_password:str):
        return self.__pwd_context__.verify(plain_text_password,hashed_password)

    def hash_password(self,password:str):
        return self.__pwd_context__.hash(password)
    
    async def create_user_tokens(self, user:User)->tuple[str,str]:
        payload = TokenPayload(name=user.name,user_id=str(user.id))
        access_token = self.__create_bearer_token(
            user_id=user.id,
            data=payload.__dict__,
            expire_hours=self.__ACCESS_TOKEN_EXPIRE_HOURS__)
        refresh_token = await self.__create_refresh_token(str(user.id))
        return (access_token, refresh_token)
        
    async def get_new_user_tokens(self,
        refresh_token:str) -> Result[tuple[str, str]]:
        result = self.__decode_jwt_refresh_token(refresh_token)
        if not result.status:
            return Result(status=False, exception=result.exception, data=None)
        
        token_payload = result.data
        is_valid = await self.__check_if_refresh_token_is_valid(token_payload)
        if not is_valid:
            return Result(status=False, data=None, exception=Unauthorized())
        
        user = await self.__user_repository.read_user_by_id(token_payload.user)
        payload = TokenPayload(name=user.name,user_id=str(user.id))
        new_access_token = self.__create_bearer_token(
            user_id=token_payload.user,
            data=payload.__dict__,
            expire_hours=self.__ACCESS_TOKEN_EXPIRE_HOURS__)

        return Result(status=True, data=(new_access_token, refresh_token), exception=None)
\end{verbatim}

Os métodos \texttt{\_\_create\_bearer\_token} e \texttt{\_\_decode\_token} são funções auxiliares utilizadas para criar, decodificar e verificar tokens, respectivamente

\begin{verbatim}
def __create_bearer_token(self,user_id:int, data:dict, expire_hours):
    data_to_enconde = data.copy()
    expire = datetime.now()+timedelta(hours=expire_hours)
    data_to_enconde["exp"] = expire
    data_to_enconde["sub"] = str(user_id)
    return jwt.encode(
        claims=data_to_enconde,
        key=self.__SECRET_KEY__,
        algorithm=self.__ALGORITHM__)

def __decode_token(self,token:str)->dict:
    return jwt.decode(
        token,
        key=self.__SECRET_KEY__,
        algorithms=self.__ALGORITHM__)
    
\end{verbatim}

\subsubsection{WebSocket}\label{subsubsec:WebSocketImplement}
%TODO Ref para a biblioteca socket.io
A implementação da conexão via WebSocket foi feita utilizando a biblioteca socket.io, que possui diversos recursos prontos que facilitam a gestão de conexões Web Socket, com por exemplo a criação de salas para disparo de notificações.

%TODO se der tempo mudar a implementação para ver a autenticação
A estrutura adotada para a gestão de conexões Web Socket foi feita de forma que o cliente deve efetuar uma requisição websocket ao \textit{endpoint} raiz da \gls{API} para ser registrado em uma sala virtual específica. Após a conclusão bem-sucedida dessa solicitação, o cliente passa a receber todas as mensagens direcionadas à sala na qual foi cadastrado.

A implementação atual contempla apenas uma sala, destinada especificamente ao envio de notificações relacionadas ao funcionamento das máquinas. Esta sala é identificada pelo identificador \texttt{NOTIFICATION\_ROOM}. Essa constante armazena o valor "\texttt{Notification}", que é o nome da sala a ser conectada.

O modo assíncrono \gls{ASGI} selecionado para a criação do servidor, e as origens permitidas para \textit{CORS} definidas como vazias.

\begin{verbatim}
socket_io_server = AsyncServer(async_mode="asgi",
    cors_allowed_origins=[])

socketio_app = ASGIApp(socketio_server=socket_io_server,
    socketio_path="")

socket_dispacher = WebSocketDispatcher(socket_io_server)

@socket_io_server.event
async def connect(sid, environ, auth):
    socket_io_server.enter_room(sid, NOTIFICATION_ROOM)
\end{verbatim}

%TODO Ref para a explicação da main.py
O objeto \texttt{socket\_io\_server} é responsável por gerenciar a comunicação \textit{WebSocket}, enquanto o \texttt{socketio\_app} cria uma aplicação \gls{ASGI} que interage com o servidor \textit{WebSocket}, e é adicionado ao servidor FastAPI. Adicionalmente, uma instância da classe \texttt{WebSocketDispatcher} foi criada para facilitar o envio de notificações através do \textit{WebSocket}.

No evento de conexão, denominado \texttt{connect}, um cliente é automaticamente adicionado à sala \texttt{NOTIFICATION\_ROOM}.

Por fim, a classe \texttt{WebSocketDispatcher} possui um método \texttt{send\_notification}, que é usado para enviar notificações. Ao chamar este método, a notificação é convertida para o formato \textit{JSON} e enviada para todos os clientes na sala \texttt{NOTIFICATION\_ROOM} através do método \texttt{emit}.

\begin{verbatim}
class WebSocketDispatcher:
    def __init__(self,socket_io_server: AsyncServer):
        self.__socket_io_server = socket_io_server
    
    async def send_notification(self,
        machine_sensor_notification:MachinesSensorAlert):
        machine_sensors_dict = machine_sensor_notification.to_json()
        await self.__socket_io_server.emit(
            NOTIFICATION_ROOM,
            machine_sensors_dict,
            room=NOTIFICATION_ROOM)
\end{verbatim}

%TODO referencia para o modulo de recebimetno de dados
A classe \texttt{WebSocketDispatcher} é utilizada pelo modulo de recebimento dos dados, detalhado em ~\ref{subsec:checkDataReceived}, para disparar notificações quando é identificado um funcionamento inadequado das maquinas.


\subsubsection{Gerenciamento de Threads para Tarefas Assíncronas}\label{subsubsec:ThreadManager}

Na arquitetura do sistema, foi identificada a necessidade de realizar tarefas de forma concorrente, sem bloquear a execução da \gls{API}. Essas tarefas são a execução do modulo de recebimento de dados, e a checagem dos metadados do sistema. Ambas tarefas devem ser executadas em paralelo com a execução da \gls{API}, sem influenciar na sua execução. Portanto, para atingir esse objetivo, um gerenciador de threads, denominado \texttt{ThreadManager}, foi implementado.

%TODO Ref para a biblioteca asyncio
A classe \texttt{ThreadManager} é projetada seguindo o padrão Singleton, assegurando que apenas uma instância seja criada, evitando assim conflitos ou redundâncias no gerenciamento das threads. Uma lista denominada \texttt{threads} é inicializada para armazenar todas as threads criadas, enquanto um loop de eventos assíncronos, atribuído à variável \texttt{loop}, é criado utilizando a biblioteca \texttt{asyncio}.

O método \texttt{start\_async\_thread} foi introduzido para facilitar a criação e o gerenciamento de tarefas assíncronas. Este método aceita uma função assíncrona, \texttt{func}, como argumento e executa as seguintes operações:

\begin{enumerate}
    \item Uma função interna \texttt{start\_function} é definida. Esta função é responsável por iniciar a execução da tarefa assíncrona.
    \item Dentro de \texttt{start\_function}, verifica-se a variável booleana \texttt{isSeted} para determinar se o loop de eventos já foi configurado. Caso contrário, o loop de eventos é configurado e a tarefa assíncrona é executada até a conclusão através do método \texttt{run\_until\_complete}.
    \item Se o loop de eventos já estiver configurado (\texttt{isSeted = True}), a tarefa assíncrona é simplesmente adicionada ao loop existente usando \texttt{create\_task}.
    \item Finalmente, uma nova thread é criada com \texttt{start\_function} como alvo e adicionada à lista \texttt{threads}. A thread é então iniciada, executando a tarefa assíncrona.
\end{enumerate}

\begin{verbatim}
import asyncio
from threading import Thread

class ThreadManager(metaclass=Singleton):
    def __init__(self):
        self.threads = []
        self.loop = asyncio.new_event_loop()
        self.isSeted = False

    def start_async_thread(self,func):
        def start_function():
            if not self.isSeted:
                asyncio.set_event_loop(self.loop)
                self.isSeted = True
                self.loop.run_until_complete(func())
            else:
                self.loop.create_task(func())

        new_thread = Thread(target = start_function)
        self.threads.append(new_thread)
        new_thread.start()
\end{verbatim}

Esta implementação permite a execução de múltiplas tarefas assíncronas em paralelo, cada uma em sua própria thread, todas gerenciadas pelo mesmo loop de eventos assíncronos.

\subsubsection{Database}\label{subsubsec:DatabaseImpl}
%TODO referencia para o motor
No processo de implementação do sistema, para estabelecer uma conexão eficiente com o banco de dados foi utilizado a biblioteca \texttt{motor} foi adotada como mecanismo.

No centro da estratégia de conexão está uma classe base, denominada \texttt{BaseDB}, que tem a responsabilidade não apenas de estabelecer a conexão com o MongoDB, mas também de definir uma série de operações básicas para a manipulação dos dados armazenados. A estrutura dessa classe é apresentada a seguir:

\begin{verbatim}
import motor
class BaseDB:
    def __init__(self):
        self.client = motor.motor_tornado.MotorClient(url, port)
\end{verbatim}

Algumas das operações fundamentais implementadas por \texttt{BaseDB} incluem:

\begin{itemize}
    \item \texttt{insert\_one}: Recebe como parâmetros o \textit{database} e a \textit{collection} correspondentes em formato de texto, e a \textit{data} a ser inserida. Insere um documento na coleção especificada.
    
    \item \texttt{insert\_many}: Recebe como parâmetros o \textit{database} e a \textit{collection} correspondentes em formato de texto, e a \textit{data} contendo vários documentos a serem inseridos. Insere vários documentos na coleção especificada.
    
    \item \texttt{read\_data\_with\_pagination}: Recebe como parâmetros o \textit{database}, a \textit{collection}, a \textit{query}, o \textit{page\_number}, o \textit{limit}, o \textit{sort\_descending\_field} e a \textit{projection}. Recupera dados com paginação, permitindo uma leitura mais organizada.
    
    \item \texttt{read\_data\_with\_limit}: Recebe como parâmetros o \textit{database}, a \textit{collection}, a \textit{query} e o \textit{limit}. Lê dados com um limite predefinido de documentos retornados.
    
    \item \texttt{read\_data}: Recebe como parâmetros o \textit{database}, a \textit{collection} e a \textit{query}. Realiza uma leitura simples de dados baseada em uma query.
    
    \item \texttt{get\_distinct\_property}: Recebe como parâmetros o \textit{database}, a \textit{collection} e a \textit{property}. Obtém propriedades distintas de uma coleção, verificando todos os documentos presentes.
    
    \item \texttt{list\_collections\_by\_db}: Recebe como parâmetro o \textit{database}. Lista todas as coleções presentes em um banco de dados específico.
    
    \item \texttt{add\_item\_into\_lists\_by\_filter}: Recebe como parâmetros o \textit{database}, a \textit{collection}, o \textit{filter}, as \textit{list\_properties} e a \textit{new\_data}. Adiciona um item em listas específicas baseado em um filtro.
    
    \item \texttt{update\_item}: Recebe como parâmetros o \textit{database}, a \textit{collection}, a \textit{data} a ser atualizada e o \textit{filter}. Atualiza um documento específico.
    
    \item \texttt{update\_many\_items}: Recebe como parâmetros o \textit{database}, a \textit{collection}, a \textit{data} a ser atualizada e o \textit{filter}. Atualiza vários documentos que atendam a um filtro.
    
    \item \texttt{count\_documents}: Recebe como parâmetros o \textit{database}, a \textit{collection} e a \textit{query}. Conta o número de documentos em uma coleção que atendem a uma consulta.
    
    \item \texttt{get\_data\_between\_dates}: Recebe como parâmetros o \textit{database}, a \textit{collection} e a \textit{query}. Recupera dados entre duas datas específicas.
\end{itemize}


Com a base de acesso estabelecida, outras classes foram desenvolvidas, herdados de \texttt{BaseDB}, para atender contextos específicos do sistema. Essas classes seguem o padrão singleton, o que garante que apenas uma instância da conexão seja criada para um contexto específico, otimizando a gestão dos recursos. Um exemplo é a classe \texttt{MongoDBIOT} destinada ao módulo de recebimento de dados:

\begin{verbatim}
class MongoDBIOT(BaseDB, metaclass=Singleton):
    def __init__(self):
        super().__init__()
\end{verbatim}

Classes semelhantes, seguindo o mesmo formato, foram criadas para outros contextos, como o acesso ao banco de dados pela \gls{API}, garantindo uma estrutura organizada e eficiente de conexão e manipulação dos dados.

\subsection{Arquivos comuns}\label{subsec:commum}

Dentro da estrutura da \gls{API}, uma pasta denominada \texttt{common} foi implementada com o intuito de centralizar componentes reutilizáveis, abrangendo múltiplos módulos e camadas. Esta organização foi estabelecida para maximizar a eficiência do desenvolvimento e a consistência do código.

\subsubsection{Modelos de Dados}\label{subsubsec:dataModel}
A seção de modelos de dados na pasta \texttt{common} abriga diversas classes que definem a estrutura dos dados utilizados. Classes que especificam usuários e dados de sensores estão presentes, e fazem o uso da biblioteca \texttt{Pydantic} para definir os modelos e criar validações dos dados.

%TODO ref pydantic,
\texttt{Pydantic} é uma biblioteca de validação de dados que adiciona tipagem estática no Python para validar que os dados recebidos correspondem a um determinado formato ou esquema. Quando usada para a construção da \gls{API}, \texttt{Pydantic} contribui para a verificação automática e coerente dos dados enviados por meio de solicitações \gls{HTTP}, e manipulações realizadas no banco de dados. Esta abordagem reduz a necessidade de codificação manual para validações de dados, acelerando assim o tempo de desenvolvimento e aumentando a robustez do código.

Para exemplificar temos a  classeNotificationSensorResponse, que é responsável por definir o modelo de dados que é retornado quando a \gls{API} recebe uma requisição solicitando as notificações de um determinado usuário. Destaca-se o uso do \texttt{BaseModel} na sistema de herança, do \texttt{Pydantic}, necessário para definir os tipos de retorno dentro do FastAPI. Além disso é utilizado a função \texttt{Field}, também do \texttt{Pydantic}, para indicar com o três pontos que é um atributo obrigatório de ser informado na construção da classe.

\begin{verbatim}
class NotificationSensorResponse(BaseModel):
    data:list[dict] = Field(...)
    total_count:int = Field(...)
\end{verbatim}

%TODO Ref para o uso de result para comunicação entre camadas
Outros modelops de dados importantes são as classes de exceções e uma classe denominada \texttt{Result}, responsável pelo tráfego de dados entre as diferentes camadas da aplicação, mostrado na implementação do modulo da \gls{API} em X.%TODO ref para a parte da implementação do modulo com controller, service e etc...
Exemplo de classe que define uma exceção do sistema.
\begin{verbatim}
class CustomBaseException(Exception):
    def __init__(self, message:str, exception, *args: object) -> None:
        self.message = message,
        self.exception = exception
        super().__init__(*args)

class GenericException(CustomBaseException):
    def __init__(self,
        message:str =   "An error has occurred",
        exception = None) -> None:

        super().__init__(message, exception)
\end{verbatim}


Classe \texttt{Result} usado para comunicação entre camadas dos módulos do sistema. O \texttt{TypeVar} é utilizado para indicar um tipo genérico para o atributo \texttt{data} da classe.

\begin{verbatim}
from typing import TypeVar, Generic
from src.common.models.exceptions.unauthorized import CustomBaseException

T = TypeVar('T')
class Result(Generic[T]):
    def __init__(self, status:bool, data:T|None, exception:CustomBaseException|None):
        self.status = status
        self.data = data
        self.exception = exception
\end{verbatim}

Destaca-se também o uso da classe \texttt{Singleton}, utilizada quando a existe a necessidade de garantir que apenas umas instância de determina classe será utilizada.

\begin{verbatim}
class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]
\end{verbatim}

%TODO referencia para boas praticas - justificando a aplicação gerir o ID e nao o próprio banco
Por último, é destacado a classe \texttt{PyObjectId}, utilizada para definir um tipo para o atributo ID das classes que representam modelos do banco de dados. Os métodos definidos para essa classe são usados internamente pelo \texttt{FastAPI} e pelo \texttt{Pydantic}.

Essa classe é necessária para que o ID possa ser corretamente convertido para texto, e retornado nas requisições. Além disso, o uso dessa classe viabiliza a manipulação do ID quando necessário, deixando a gestão dos identificadores únicos para a aplicação e não para o banco de dados, como uma boa prática para desenvolvimento de sistemas.

\begin{verbatim}
class PyObjectId(ObjectId):
    @classmethod
    def __get_validators__(cls):
        yield cls.validate

    @classmethod
    def validate(cls, v):
        if not ObjectId.is_valid(v):
            raise ValueError("Invalid object id")
        return ObjectId(v)

    @classmethod
    def __modify_schema__(cls, field_schema):
        field_schema.update(type="string")
\end{verbatim}

\subsubsection{Funções Helpers}

A seção de funções \textit{helpers} na pasta \texttt{common} foi construída para conter métodos que sejam comum em diferentes módulos do sistema, evitando a duplicação de código e padronizando o funcionamento.

%TODO ref para o datatype na subsections eguinte de constantes
Um exemplo dessas funções é a conversão de \texttt{Datatype} para coleções do MongoDB. O código a seguir ilustra um desses processos:

\begin{verbatim}
def sensor_name_to_processed_collection(
    sensor_name:Datatype)->str:
    
    sensor = (sensor_name.name).capitalize()
    return IOT_AGGREGATION_COLLECTION.replace("NAME", sensor)

\end{verbatim}

Estas funções são empregadas para determinar os nomes corretos das coleções em de acordo com o tipo de dado a ser tratado e manipulado pelos modulos. Funções como \texttt{sensor\_name\_to\_processed\_collection} e \texttt{sensor\_name\_to\_raw\_data\_collection} convertem entre nomes de sensores e nomes de coleções. 
%TODO ref para o datatype na subsections eguinte de constantes
Adicionalmente, uma série de funções foi desenvolvida para mapear o nome processado da coleção, de volta para o \texttt{Datatype} correspondente, garantindo uma manipulação de dados mais segura e coerente.


\subsubsection{Constantes}
%TODO ref para websocker room
Por fim, a seção de constantes armazena uma série de valores fixos que são usados em várias partes do sistema. Isso inclui nomes de bancos de dados, tipos de alertas, salas de websocket, e outros que forem necessários.

Dentre as constantes destaca-se a \texttt{DataType}, que é um \textit{enum} que padroniza os tipos de dados que podem ser recebidos dos sensores. Esta padronização é empregada em diversos módulos para assegurar que os dados sejam recebidos, processados, armazenados e retornados de maneira consistente e correta.

\begin{verbatim}
from enum import Enum

class Datatype(Enum):
    PRESSURE = "PRESSURE"
    TEMPERATURE = "TEMPERATURE"
    VOLTAGE = "VOLTAGE"
    CURRENT = "CURRENT"
    SPEED = "SPEED"
    ACCELERATION = "ACCELERATION"
    DISTANCE = "DISTANCE"
    HUMIDITY = "HUMIDITY"
    FORCE = "FORCE"
    PRODUCTION_COUNTER = "PRODUCTION_COUNTER"
\end{verbatim}

\subsection{Módulos}\label{subsec:modules}
A \gls{API} foi estruturada em módulos, cada um com responsabilidade para gerenciar um determinado contexto. Abaixo são listados os módulos desenvolvidos.

\begin{enumerate}
    \item \textbf{IOT Analytics}: Modulo responsável por gerenciar o acesso as informações dos sensores, tanto os dados em tempo real via stream, quanto as informações processadas pelo modulo de processamento de dados, explicado em ~\ref{sec:ImplModuloProcessamento}.
    \item \textbf{Notifications}: Modulo responsável por gerenciar o acesso as notificações.
    \item \textbf{User}: Modulo responsável por gerir as informações dos usuários do sistema, e realização da autenticação explicada em ~\ref{subsubsec:auth}.
    \item \textbf{Downtime Analytics}: Modulo usado para disponibilizar os dados de teste da paragem das maquinas. Esse modulo alimenta a tela que exibe as informações de paragem das maquinas.

\end{enumerate}

Cada modulo seguiu um padrão de ter uma camada para o recebimento  das requisições \gls{HTTP}, o \texttt{controller}, outra para tratar a requisição de acordo com as regras de negócio, o \texttt{service}, e o \texttt{repositoy}, para disponibilizar métodos de acesso e manipulação das informações no banco de dados.

\subsubsection{Controller}\label{subsubsec:controller}
O controller tem a função de receber as requisições \gls{HTTP}, enviar as informações recebidas para a camada de serviço, e realizar o retorno adequado, com as informações formatadas, e código \gls{HTTP} correto.


Para exemplificar o funcionamento do controller, um exemplo específico será apresentado. O seguinte fragmento de código representa o router da \gls{API} para os dados dos sensores \gls{IoT}:

\begin{verbatim}
iot_data_router = APIRouter(tags=["IOT Data"], dependencies=[Depends(auth_middleware)])

service = ServiceIOT()

@iot_data_router.get("/realtime")
async def real_time_iot(): 
    def get_real_time_data():
        sensor = SensorValue()
        while True:
            time.sleep(1)
            lista_json = [machine.to_json() for machine in sensor.machine_list]
            last_data = json.dumps(lista_json)
            yield bytes(last_data, "utf-8")

    return StreamingResponse(
        get_real_time_data(),
        media_type="application/octet-stream")
\end{verbatim}

%TODO adicionar referencia para a implementação da autenticação
Neste exemplo, o controller faz uso do \texttt{APIRouter} para criar rotas associadas aos dados da IoT. Um middleware de autenticação é aplicado como uma dependência, como mostrado no detalhamento da autenticação em ref X, garantindo que apenas usuários autenticados possam acessar essas rotas. Nesse caso, ao aplicar o middleware na criação do \texttt{iot\_data\_router}, é garantido que todos os \texttt{endpoints} criados a partir dele precisem de autenticação.

Logo abaixo é criada uma instância do serviço que deve ser utilizado pelos \texttt{endpoints} para responder as requisições recebidas.

%TODO adicionar referencia para a implementação do modulo de recebimento de dados
A rota \texttt{/realtime} é designada para fornecer dados em tempo real. Uma função interna, \texttt{get\_real\_time\_data}, é 
responsável por coletar esses dados do \texttt{SensorValue}, explicado em ref X. Nesse endpoint, a \gls{API} pega os valores atuais e retorna uma \texttt{StreamingResponse}, que envia os dados em tempo real como um fluxo contínuo.

As outras rotas, como \texttt{/machines\_in\_sensor} e \texttt{/graph\_info}, operam de maneira semelhante, mas com diferentes responsabilidades. Elas fazem chamadas para a instancia de \texttt{ServiceIOT} para recuperar informações específicas e retorná-las ao cliente. Caso ocorra uma exceção ou erro, um \texttt{HTTPException} é lançado com um código de status HTTP apropriado e uma mensagem de erro detalhada.

Nesses dois endpoints é importante destacar a especificação do \texttt{response\_model}, para que ocorra validações automáticas pelo framework antes do dado ser retornado, garantido a consistência nos dados retornados.

\begin{verbatim}
@iot_data_router.get("/machines_in_sensor", response_model=list[MachinesSensor])
async def get_machines_in_sensor():
    result = await service.get_all_machines_processed_info()
    if result.status:
        return result.data
    
    raise HTTPException(status_code=500, detail=result.exception.message)

@iot_data_router.get("/graph_info", response_model=list[ProcessedData])
async def get_graph_info(machine:str, sensor:Datatype, initial_date:datetime, end_date:datetime):
    result = await service.get_processed_data(
        machine=machine,
        data_type=sensor,
        initial_date=initial_date,
        end_date=end_date)
    
    if result.status:
        return result.data
    
    raise HTTPException(status_code=500, detail=result.exception.message)
\end{verbatim}

\subsubsection{Service}\label{subsubsec:service}
A camada de serviço serve para aplicar as devidas regras antes de retornar os dados para a camada de controle ~\ref{subsubsec:controller}. Pode acessar a camada de repositório para realizar a leitura ou escrita de dados, e deve retornar os dados para a camada de controle usando a classe \texttt{Result}, mostrada na seção ~\ref{subsec:commum}, para que possa ser identificado corretamente o resultado do processamento realizado, e o retorno adequado seja dados para o cliente que realizou a requisição. 

Para uma compreensão mais profunda, um exemplo específico da implementação da camada de serviço segue abaixo:

\begin{verbatim}
class ServiceIOT:
    def __init__(self):
        self.__repository = RepositoryIOT()
        self.__database__ = MongoDB()
        self.appMetadata = MetadataRepository()
            
    async def get_processed_data(self,
        machine:str,
        data_type:Datatype,
        initial_date:datetime,
        end_date:datetime)-> Result[list[ProcessedData]]:
        try:
            alert_parameter = await self.appMetadata.get_sensor_alert_value(
            data_type)

            processed_data = await self.__repository.read_iot_processed_data__(
                machine=machine,
                datatype=data_type,
                initial_date=initial_date,
                end_date=end_date,
                sort_by_field="more_recent_register")
            
            for data in processed_data:
                data["alert_parameter"] = alert_parameter
            return Result[list[MachinesSensor]](
                status=True,
                data=processed_data,
                exception=None)
        except Exception as ex:
            return Result[list[MachinesSensor]](
                status=False,
                data=None,
                exception=GenericException(exception=ex))
\end{verbatim}

Nesta implementação, a classe \texttt{ServiceIOT} é inicializada com instâncias de \texttt{RepositoryIOT} e \texttt{MetadataRepository}, permitindo que o serviço acesse as camadas de repositório e metadados correspondentes.

O método \texttt{get\_processed\_data} serve para obter dados processados com base em diversos parâmetros como máquina, tipo de dados e intervalo de datas. Inicialmente, um valor de alerta é recuperado do metadado do sensor para o tipo de dados fornecido. Posteriormente, os dados processados são lidos do repositório. A cada entrada de dados recuperada, o valor de alerta é adicionado como um novo campo. O método retorna um objeto \texttt{Result} encapsulando esses dados. O objeto \texttt{Result} é detalhado em ~\ref{subsec:commum}.

O método \texttt{get\_all\_machines\_processed\_info} recupera informações sobre todas as máquinas e sensores processados. Ele itera através das coleções de dados processados, agregando informações de máquinas e sensores. Em caso de sucesso, ele retorna um objeto \texttt{Result} contendo uma lista de máquinas e seus sensores correspondentes.

\begin{verbatim}
async def get_all_machines_processed_info(
    self)-> Result[list[MachinesSensor]]:
    try:
        collection_list = 
            await self.__repository.get_processed_data_collections()
        machine_sensors: list[MachinesSensor] = []
        for collection in collection_list:
            machine_list = await self.__repository
                .get_distinct_machines_by_collection(collection)
            sensor = processed_collection_to_sensor_name(collection)

            for machine in machine_list:
                matching_sensor = 
                next((data for data in machine_sensors 
                    if data.machine == machine), None)
                if matching_sensor:
                    matching_sensor.sensors.append(sensor)
                else:
                    machine_sensors.append(MachinesSensor(
                        machine=machine,
                        sensors=[sensor]))
        
        return Result[list[MachinesSensor]](
            status=True,
            data=machine_sensors,
            exception=None)
    except Exception as ex:
        print(ex)
        return Result[bool](
            status=False,
            data=None,
            exception=GenericException(exception=ex)) 
\end{verbatim}

O último método, \texttt{read\_raw\_data\_by\_id}, serve para ler dados brutos com base em um identificador e tipo de dados. Ele acessa o repositório correspondente para recuperar os dados e retorna um objeto \texttt{Result} contendo esses dados ou uma exceção, se aplicável.
\begin{verbatim}
async def read_raw_data_by_id(self,
    raw_data_id:str,
    datatype:Datatype) -> Result:
    try:
        collection = sensor_name_to_raw_data_collection(datatype)
        result = await self.__repository.read_raw_data(collection,raw_data_id)
        return Result(status=True, data=result, exception=None) 
    except Exception as ex:
        return Result[bool](
            status=False,
            data=None,
            exception=GenericException(exception=ex)) 

\end{verbatim}
Esta implementação exemplifica como a camada de serviço interage com as camadas de repositório e acessa metadados metadados, e como ela prepara os dados para serem enviados de volta ao controller, garantindo assim um fluxo de dados coeso e eficiente através das diversas camadas da aplicação.

\subsubsection{Respository}\label{subsubsec:repository}
Por fim a camada a camada de repositório é responsável por ter acesso ao banco de dados e realizar as operações de leitura e escrita de acordo com as necessidades. Essa camada instancia uma conexão com banco de dados, e seus métodos utilizam os métodos base definidos pela infraestrutura de conexão com o banco, em ~\ref{subsubsec:DatabaseImpl}, para realizar a operações de acordo com o contexto daquele modulo.

O código a seguir fornece um exemplo da implementação dessa camada:

\begin{verbatim}
class RepositoryIOT:
    def __init__(self):
        self.__database__ = MongoDB()
    
    async def get_processed_data_collections(self):
        collection_list = 
            await self.__database__.list_collections_by_db(
            IOT_PROCESSED_DATA)
    
        return collection_list
        
    async def get_distinct_machines_by_collection(self, collection:str):
        machine_list = 
            await self.__database__.get_distinct_property(
                IOT_PROCESSED_DATA,
                collection,
                "machine")

        return machine_list
    
    async def read_raw_data(self, collection:str, raw_data_id:str):
        result = await self.__database__.read_data(
            IOT_DATABASE,
            collection,
            {"_id":ObjectId(raw_data_id)})

        return result
    
    async def read_iot_processed_data__(self, machine:str, datatype:Datatype, 
        initial_date:datetime, end_date:datetime, 
        sort_by_field:str) -> list[ProcessedData]:
        
        try:
            collection = sensor_name_to_processed_collection(datatype)
            query = {
                "machine":machine,
                sort_by_field:{
                    "$gte":initial_date,
                    "$lte":end_date
                }
            }
            result = await self.__database__.get_data_between_dates(
                IOT_PROCESSED_DATA,
                collection,query)
            return result
        except Exception as ex:
            print(ex)
            raise ex
\end{verbatim}

Na inicialização da classe \texttt{RepositoryIOT}, uma conexão com o MongoDB é instanciada. O método \texttt{get\_processed\_data\_collections} é utilizado para listar todas as coleções de dados processados do banco de dados \texttt{IOT\_PROCESSED\_DATA}. Este método faz uma chamada direta ao método de listagem de coleções fornecido pela classe \texttt{MongoDB}.

O método \texttt{get\_distinct\_machines\_by\_collection} é responsável por recuperar uma lista de máquinas distintas para uma determinada coleção. Ele faz isso através do método \texttt{get\_distinct\_property} do banco de dados.

O método \texttt{read\_raw\_data} serve para ler dados brutos de uma coleção específica, utilizando o ID dos dados como parâmetro de pesquisa. Ele faz uma chamada ao método \texttt{read\_data} da classe \texttt{MongoDB}, fornecendo os parâmetros necessários para a leitura dos dados.

Por fim, o método \texttt{read\_iot\_processed\_data\_\_} é utilizado para ler dados processados com base em diversos critérios como máquina, tipo de dados e intervalo de datas. Uma query é construída para esse fim e passada ao método \texttt{get\_data\_between\_dates} da classe \texttt{MongoDB}.

Cada um desses métodos auxilia na manutenção de uma separação clara de responsabilidades, permitindo que a camada de serviço mantenha um foco estrito na lógica de negócios, enquanto a camada de repositório gerencia as operações do banco de dados.



