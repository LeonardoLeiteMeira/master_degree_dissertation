% \chapter{Testes/Avaliação/Discussão}\label{cap:test}

% Este capítulo apresenta os testes realizados para verificar que o projeto desenvolvido cumpre os objetivos assumidos e resolve, de facto, o problema descrito na Análise/Modelação. 

% Para uma melhor compreensão, os resultados de cada teste devem ser precedidos de uma descrição, mesmo que resumida, do teste realizado e dos resultados esperados.

% Os resultados do trabalho são comentados, acrescentando-lhe valor:

% \begin{itemize}
% 	\item  O que é que se pode inferir ou conjeturar dos resultados obtidos? 
% 	\item O que poderia/deveria ter sido feito de forma diferente? 
% 	\item Onde se foi além dos objetivos iniciais?
% 	\item  Quais os objetivos que ficaram por cumprir, e porquê ?
% \end{itemize}

\chapter{Implementação}\label{cap:test}

This chapter presents and describes the tests that were developed to check if the project fulfills the objectives and solves the problem described in Analysis/Methodology.

To better understand, the results of each test should be preceded by a description of the test and the expected results.

The work results are commented, including:

\begin{itemize}
	\item  What can be learned from the results?
	\item What could be done differently? 
	\item What was beyond initial objectives?
	\item What are the objectives there were not met and why?
\end{itemize}


\subsection[Implementação do banco de dados]{Implementação do banco de dados}
- Databases
- Collections

\subsection[Implementação da API]{Implementação da API}

- Uvicorn usado pelo FastAPI e sua forma asyncrona
- Biblioteca Motor usada para acesso ao mongoDB
- Biblioteca Pydantic para criação dos modelos e tipos
- Web socket para envio de notificações
- Biblioteca Jose para autenticação
- Comunicação entre as camadas com a classe Result
- Contratos de interfaces
- Tratamento de erros com classes personalizadas




Para interpretar e extrair informações da mensagem recebida do multicast, é crucial decodificar adequadamente a mensagem de acordo com o protocolo definido anteriormente. A implementação dessa decodificação é feita pela função \texttt{\_\_parse\_multicast\_message}. 

\subsection{Interpretação dos Bytes}

A primeira parte da decodificação envolve interpretar os bytes da mensagem. A função auxiliar \texttt{\_\_parse\_bytes} é utilizada para essa tarefa. Dada uma sequência de bytes, esta função interpreta os bytes utilizando a ordem big-endian (onde os bytes mais significativos vêm primeiro):

\begin{verbatim}
def __parse_bytes(self, bytes):
    data = int.from_bytes(bytes, byteorder='big')
    high_data = (data >> 8) & 0xFF
    low_data = data & 0xFF

    return (high_data,low_data)
\end{verbatim}

Aqui, \texttt{data} contém o valor inteiro dos bytes fornecidos. O byte de ordem superior (High) é extraído deslocando o valor 8 bits para a direita e aplicando uma operação "E" (\&). O byte de ordem inferior (Low) é simplesmente obtido aplicando a operação "E" com \texttt{0xFF}.

\subsection{Decodificação da Mensagem}

Com a capacidade de interpretar os bytes, a função principal \texttt{\_\_parse\_multicast\_message} pode começar a decodificação:

\begin{itemize}
    \item Primeiro, ela extrai o tipo de máquina e o número da máquina dos dois primeiros bytes da mensagem.
    
    \item O terceiro byte da mensagem é então interpretado como o tipo da mensagem. Se o tipo da mensagem for \texttt{2}, a função retornará diretamente uma solicitação para publicar.
    
    \item Os bytes 4 e 5 são interpretados como o ID do sensor, que contém a quantidade física sendo medida e o número do sensor.
    
    \item Os bytes 6 e 7 são usados para extrair o tipo de dados e seu significado.
    
    \item Finalmente, os bytes 8 e 9 são usados para determinar o comprimento dos dados que seguem.
\end{itemize}

A informação extraída é então organizada em um dicionário para representação clara e fácil acesso aos componentes individualmente:

\begin{verbatim}
message_dict = {
    'Machine': {
        ...
    },
    'Type': ...,
    'Sensor': {
        ...
    },
    'MeaningOfData': {
        ...
    }
}
\end{verbatim}

Esta estrutura permite uma representação clara e modular da mensagem decodificada, tornando fácil a integração e utilização em outras partes do sistema.



\subsection[Implementação do módulo de processamento de dados]{Implementação do módulo de processamento de dados}
- Leitura dos dados de acordo com o processamento realizado anteriormente
- Uso da biblioteca pandas
- Funcionamento do BoxPlot para realizar analise estatística

\subsection[Implementação do frontend]{Implementação do frontend}
- Criação de paginas componentes de layouts
- Recharts
- Material UI
- Days JS
- Criação da camada de dados com o Context API
- Acesso externo a API
- Axios e fetch

\subsection[Adaptando a implementação para outros contextos]{Adaptando a implementação para outros contextos}
Discussão sobre a reutização do sistema para outros contextos....
- como fazer
- alterações necessarias
